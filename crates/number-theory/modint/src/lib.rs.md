---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: crates/algebraic/algebraic/src/lib.rs
    title: crates/algebraic/algebraic/src/lib.rs
  _extendedRequiredBy:
  - icon: ':heavy_check_mark:'
    path: crates/convolution/convolution-arbitrary-mod/src/lib.rs
    title: crates/convolution/convolution-arbitrary-mod/src/lib.rs
  - icon: ':warning:'
    path: crates/convolution/convolution-naive/src/lib.rs
    title: crates/convolution/convolution-naive/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/convolution/convolution-ntt-friendly/src/lib.rs
    title: crates/convolution/convolution-ntt-friendly/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/convolution/convolution-u64/src/lib.rs
    title: crates/convolution/convolution-u64/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/graph/count-spanning-tree-directed/src/lib.rs
    title: crates/graph/count-spanning-tree-directed/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/graph/count-spanning-tree-undirected/src/lib.rs
    title: crates/graph/count-spanning-tree-undirected/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/number-theory/combination/src/lib.rs
    title: crates/number-theory/combination/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/number-theory/q-binomial/src/lib.rs
    title: crates/number-theory/q-binomial/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/number-theory/stirling-first-fixed-k/src/lib.rs
    title: crates/number-theory/stirling-first-fixed-k/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/number-theory/stirling-first/src/lib.rs
    title: crates/number-theory/stirling-first/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/number-theory/stirling-second-fixed-k/src/lib.rs
    title: crates/number-theory/stirling-second-fixed-k/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/number-theory/stirling-second/src/lib.rs
    title: crates/number-theory/stirling-second/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/polynomial/berlekamp-massey/src/lib.rs
    title: crates/polynomial/berlekamp-massey/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/polynomial/bostan-mori/src/lib.rs
    title: crates/polynomial/bostan-mori/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/polynomial/composition/src/lib.rs
    title: crates/polynomial/composition/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/polynomial/compositional-inverse/src/lib.rs
    title: crates/polynomial/compositional-inverse/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/polynomial/formal-power-series/src/lib.rs
    title: crates/polynomial/formal-power-series/src/lib.rs
  - icon: ':warning:'
    path: crates/polynomial/lagrange-interpolation/src/lib.rs
    title: crates/polynomial/lagrange-interpolation/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/polynomial/polynomial-interpolation/src/lib.rs
    title: crates/polynomial/polynomial-interpolation/src/lib.rs
  - icon: ':warning:'
    path: crates/polynomial/power-projection/src/lib.rs
    title: crates/polynomial/power-projection/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/polynomial/shift-of-sampling-points/src/lib.rs
    title: crates/polynomial/shift-of-sampling-points/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/string/wildcard-pattern-matching/src/lib.rs
    title: crates/string/wildcard-pattern-matching/src/lib.rs
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: verify/binomial_coefficient_prime_mod/src/main.rs
    title: verify/binomial_coefficient_prime_mod/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/bitwise_or_convolution/src/main.rs
    title: verify/bitwise_or_convolution/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/composition_of_formal_power_series_large/src/main.rs
    title: verify/composition_of_formal_power_series_large/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/compositional_inverse_of_formal_power_series_large/src/main.rs
    title: verify/compositional_inverse_of_formal_power_series_large/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/convolution_mod/src/main.rs
    title: verify/convolution_mod/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/convolution_mod_1000000007/src/main.rs
    title: verify/convolution_mod_1000000007/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/count_spanning_tree_directed/src/main.rs
    title: verify/count_spanning_tree_directed/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/count_spanning_tree_undirected/src/main.rs
    title: verify/count_spanning_tree_undirected/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/discrete_logarithm_mod/src/main.rs
    title: verify/discrete_logarithm_mod/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/division_of_polynomials/src/main.rs
    title: verify/division_of_polynomials/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/exp_of_formal_power_series/src/main.rs
    title: verify/exp_of_formal_power_series/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/find_linear_recurrence/src/main.rs
    title: verify/find_linear_recurrence/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/inv_of_formal_power_series/src/main.rs
    title: verify/inv_of_formal_power_series/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/inverse_matrix/src/main.rs
    title: verify/inverse_matrix/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/kth_term_of_linearly_recurrent_sequence/src/main.rs
    title: verify/kth_term_of_linearly_recurrent_sequence/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/log_of_formal_power_series/src/main.rs
    title: verify/log_of_formal_power_series/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/matrix_det/src/main.rs
    title: verify/matrix_det/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/matrix_product/src/main.rs
    title: verify/matrix_product/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/multipoint_evaluation/src/main.rs
    title: verify/multipoint_evaluation/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/point_set_tree_path_composite_sum_fixed_root/src/main.rs
    title: verify/point_set_tree_path_composite_sum_fixed_root/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/polynomial_interpolation/src/main.rs
    title: verify/polynomial_interpolation/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/polynomial_taylor_shift/src/main.rs
    title: verify/polynomial_taylor_shift/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/pow_of_formal_power_series/src/main.rs
    title: verify/pow_of_formal_power_series/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/pow_of_matrix/src/main.rs
    title: verify/pow_of_matrix/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/q_binomial_coefficient_prime_mod/src/main.rs
    title: verify/q_binomial_coefficient_prime_mod/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/range_affine_point_get/src/main.rs
    title: verify/range_affine_point_get/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/range_parallel_unionfind/src/main.rs
    title: verify/range_parallel_unionfind/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/shift_of_sampling_points_of_polynomial/src/main.rs
    title: verify/shift_of_sampling_points_of_polynomial/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/sqrt_mod/src/main.rs
    title: verify/sqrt_mod/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/sqrt_of_formal_power_series/src/main.rs
    title: verify/sqrt_of_formal_power_series/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/static_rectangle_add_rectangle_sum/src/main.rs
    title: verify/static_rectangle_add_rectangle_sum/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/stirling_number_of_the_first_kind/src/main.rs
    title: verify/stirling_number_of_the_first_kind/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/stirling_number_of_the_first_kind_fixed_k/src/main.rs
    title: verify/stirling_number_of_the_first_kind_fixed_k/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/stirling_number_of_the_second_kind/src/main.rs
    title: verify/stirling_number_of_the_second_kind/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/stirling_number_of_the_second_kind_fixed_k/src/main.rs
    title: verify/stirling_number_of_the_second_kind_fixed_k/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/subset_convolution/src/main.rs
    title: verify/subset_convolution/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/sum_of_multiplicative_function/src/main.rs
    title: verify/sum_of_multiplicative_function/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/tree_path_composite_sum/src/main.rs
    title: verify/tree_path_composite_sum/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/trie_yuki1269/src/main.rs
    title: verify/trie_yuki1269/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/unionfind_with_potential_non_commutative_group/src/main.rs
    title: verify/unionfind_with_potential_non_commutative_group/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/vertex_set_path_composite/src/main.rs
    title: verify/vertex_set_path_composite/src/main.rs
  _isVerificationFailed: false
  _pathExtension: rs
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    links:
    - https://rsk0315.hatenablog.com/entry/2023/04/29/043512
  bundledCode: "Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/onlinejudge_verify/documentation/build.py\"\
    , line 71, in _render_source_code_stat\n    bundled_code = language.bundle(stat.path,\
    \ basedir=basedir, options={'include_paths': [basedir]}).decode()\n          \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  File \"/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/onlinejudge_verify/languages/rust.py\"\
    , line 288, in bundle\n    raise NotImplementedError\nNotImplementedError\n"
  code: "use std::{\n    fmt,\n    hash::Hash,\n    iter::{Product, Sum},\n    num::ParseIntError,\n\
    \    ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},\n\
    \    str::FromStr,\n    sync::atomic::{self, AtomicU32, AtomicU64},\n};\n\nuse\
    \ algebraic::{One, Zero};\n\n/// \u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u6CD5\
    \u3092\u6307\u5B9A\u3057\u305F ModInt\n#[derive(Clone, Copy, Default, PartialEq,\
    \ Eq, Hash)]\n#[repr(transparent)]\npub struct StaticModInt<const P: u32>(u32);\n\
    \n/// \u5B9F\u884C\u6642\u306B\u6CD5\u3092\u6307\u5B9A\u3067\u304D\u308B ModInt\n\
    #[derive(Clone, Copy, Default, PartialEq, Eq, Hash)]\n#[repr(transparent)]\npub\
    \ struct DynamicModInt(u32);\n\npub type ModInt998244353 = StaticModInt<998_244_353>;\n\
    pub type ModInt1000000007 = StaticModInt<1_000_000_007>;\n\npub trait ModInt:\n\
    \    Default\n    + Zero\n    + One\n    + FromStr\n    + From<i8>\n    + From<i16>\n\
    \    + From<i32>\n    + From<i64>\n    + From<i128>\n    + From<isize>\n    +\
    \ From<u8>\n    + From<u16>\n    + From<u32>\n    + From<u64>\n    + From<u128>\n\
    \    + From<usize>\n    + Copy\n    + Eq\n    + Hash\n    + fmt::Display\n   \
    \ + fmt::Debug\n    + Neg<Output = Self>\n    + Add<Output = Self>\n    + Sub<Output\
    \ = Self>\n    + Mul<Output = Self>\n    + Div<Output = Self>\n    + AddAssign\n\
    \    + SubAssign\n    + MulAssign\n    + DivAssign\n{\n    fn modulus() -> u32;\n\
    \    fn raw(val: u32) -> Self;\n    fn val(self) -> u32;\n    fn inv(self) ->\
    \ Self;\n    fn pow(self, k: usize) -> Self;\n    fn sqrt(self) -> Option<Self>;\n\
    }\n\nconst fn mul(x: u32, y: u32, m: u32) -> u32 {\n    (x as u64 * y as u64 %\
    \ m as u64) as u32\n}\n\nconst fn pow(x: u32, mut n: u32, m: u32) -> u32 {\n \
    \   if m == 1 {\n        return 0;\n    }\n    let mut r = 1u64;\n    let mut\
    \ y = (x % m) as u64;\n    while n != 0 {\n        if n & 1 != 0 {\n         \
    \   r = r * y % m as u64;\n        }\n        y = y * y % m as u64;\n        n\
    \ >>= 1;\n    }\n    r as u32\n}\n\nconst fn is_prime(n: u32) -> bool {\n    match\
    \ n {\n        _ if n <= 1 => return false,\n        2 | 7 | 61 => return true,\n\
    \        _ if n & 1 == 0 => return false,\n        _ => {}\n    }\n    let mut\
    \ d = n - 1;\n    while d & 1 == 0 {\n        d >>= 1;\n    }\n    let a = [2,\
    \ 7, 61];\n    let mut i = 0;\n    while i < 3 {\n        let mut t = d;\n   \
    \     let mut y = pow(a[i], t, n);\n        while t != n - 1 && y != 1 && y !=\
    \ n - 1 {\n            y = (y as u64 * y as u64 % n as u64) as u32;\n        \
    \    t <<= 1;\n        }\n        if y != n - 1 && t & 1 == 0 {\n            return\
    \ false;\n        }\n        i += 1;\n    }\n    true\n}\n\nconst fn extgcd(mut\
    \ a: u32, b: u32) -> (u32, u32) {\n    a = a % b;\n    if a == 0 {\n        return\
    \ (b, 0);\n    }\n\n    let mut s = b as i64;\n    let mut t = a as i64;\n   \
    \ let mut m0 = 0;\n    let mut m1 = 1;\n    while t != 0 {\n        let u = s\
    \ / t;\n        s -= t * u;\n        m0 -= m1 * u;\n        let tmp = s;\n   \
    \     s = t;\n        t = tmp;\n        let tmp = m0;\n        m0 = m1;\n    \
    \    m1 = tmp;\n    }\n    if m0 < 0 {\n        m0 += b as i64 / s;\n    }\n \
    \   (s as u32, m0 as u32)\n}\n\nconst fn primitive_root(m: u32) -> u32 {\n   \
    \ match m {\n        2 => return 1,\n        167_772_161 => return 3,\n      \
    \  469_762_049 => return 3,\n        754_974_721 => return 11,\n        998_244_353\
    \ => return 3,\n        _ => {}\n    }\n    let mut divs = [0; 20];\n    divs[0]\
    \ = 2;\n    let mut cnt = 1;\n    let mut x = (m - 1) / 2;\n    while x % 2 ==\
    \ 0 {\n        x /= 2;\n    }\n    let mut i = 3;\n    while i < std::u32::MAX\
    \ {\n        if i as u64 * i as u64 > x as u64 {\n            break;\n       \
    \ }\n        if x % i == 0 {\n            divs[cnt] = i;\n            cnt += 1;\n\
    \            while x % i == 0 {\n                x /= i;\n            }\n    \
    \    }\n        i += 2;\n    }\n    if x > 1 {\n        divs[cnt] = x;\n     \
    \   cnt += 1;\n    }\n    let mut g = 2;\n    loop {\n        let mut i = 0;\n\
    \        while i < cnt {\n            if pow(g, (m - 1) / divs[i], m) == 1 {\n\
    \                break;\n            }\n            i += 1;\n        }\n     \
    \   if i == cnt {\n            break g;\n        }\n        g += 1;\n    }\n}\n\
    \nconst fn ntt_info(\n    m: u32,\n) -> (\n    u32,\n    usize,\n    [u32; 30],\n\
    \    [u32; 30],\n    [u32; 30],\n    [u32; 30],\n    [u32; 30],\n    [u32; 30],\n\
    ) {\n    let g = primitive_root(m);\n    let rank2 = (m - 1).trailing_zeros()\
    \ as usize;\n    let mut root = [0; 30];\n    let mut iroot = [0; 30];\n    let\
    \ mut rate2 = [0; 30];\n    let mut irate2 = [0; 30];\n    let mut rate3 = [0;\
    \ 30];\n    let mut irate3 = [0; 30];\n\n    root[rank2] = pow(g, (m - 1) >> rank2,\
    \ m);\n    iroot[rank2] = extgcd(root[rank2], m).1;\n    let mut i = rank2;\n\
    \    while i > 0 {\n        i -= 1;\n        root[i] = mul(root[i + 1], root[i\
    \ + 1], m);\n        iroot[i] = mul(iroot[i + 1], iroot[i + 1], m);\n    }\n\n\
    \    let mut prod = 1;\n    let mut iprod = 1;\n    let mut i = 0;\n    while\
    \ i + 2 <= rank2 {\n        rate2[i] = mul(root[i + 2], prod, m);\n        irate2[i]\
    \ = mul(iroot[i + 2], iprod, m);\n        prod = mul(prod, iroot[i + 2], m);\n\
    \        iprod = mul(iprod, root[i + 2], m);\n        i += 1;\n    }\n\n    let\
    \ mut prod = 1;\n    let mut iprod = 1;\n    let mut i = 0;\n    while i + 3 <=\
    \ rank2 {\n        rate3[i] = mul(root[i + 3], prod, m);\n        irate3[i] =\
    \ mul(iroot[i + 3], iprod, m);\n        prod = mul(prod, iroot[i + 3], m);\n \
    \       iprod = mul(iprod, root[i + 3], m);\n        i += 1;\n    }\n\n    (g,\
    \ rank2, root, iroot, rate2, irate2, rate3, irate3)\n}\n\n// reference: https://rsk0315.hatenablog.com/entry/2023/04/29/043512\n\
    fn rat_convert(x: u64, m: u64, d: u64) -> Option<(u64, u64)> {\n    let n = m\
    \ / (2 * d);\n    if x < n && 1 < d {\n        return Some((x, 1));\n    }\n\n\
    \    let mut l = (0, 1);\n    let mut r = (1, 0);\n    loop {\n        let num\
    \ = l.0 + r.0;\n        let den = l.1 + r.1;\n\n        let (i, q) = match (num\
    \ * m).cmp(&(den * x)) {\n            std::cmp::Ordering::Less => {\n        \
    \        // num/den < x/m\n                // k = max {k: m (l.0 * k * r.0) <\
    \ x (l.1 + k * r.1)}\n                // k = max {k: k (m r.0 - x r.1) < x l.1\
    \ - m l.0}\n                let k = (x * l.1 - m * l.0 - 1) / (m * r.0 - x * r.1);\n\
    \                l.0 += k * r.0;\n                l.1 += k * r.1;\n          \
    \      l\n            }\n            std::cmp::Ordering::Equal => return None,\n\
    \            std::cmp::Ordering::Greater => {\n                // num/den > x/m\n\
    \                // k = max {k: m (k l.0 + r.0) > x (k l.1 + r.1)}\n         \
    \       // k = max {k: m r.0 - x r.1 > k (x l.1 - m l.0)}\n                let\
    \ k = (m * r.0 - x * r.1 - 1) / (x * l.1 - m * l.0);\n                r.0 += k\
    \ * l.0;\n                r.1 += k * l.1;\n                r\n            }\n\
    \        };\n\n        if q * x < i * m {\n            continue;\n        }\n\
    \        let p = q * x - i * m;\n        if p < n && q < d {\n            return\
    \ Some((p, q));\n        }\n    }\n}\n\nimpl<const P: u32> ModInt for StaticModInt<P>\
    \ {\n    #[inline(always)]\n    fn modulus() -> u32 {\n        P\n    }\n\n  \
    \  #[inline]\n    fn raw(val: u32) -> Self {\n        Self(val)\n    }\n\n   \
    \ #[inline]\n    fn val(self) -> u32 {\n        self.0\n    }\n\n    #[inline]\n\
    \    fn inv(self) -> Self {\n        self.inv()\n    }\n\n    fn pow(self, k:\
    \ usize) -> Self {\n        self.pow(k)\n    }\n\n    fn sqrt(self) -> Option<Self>\
    \ {\n        self.sqrt()\n    }\n}\n\nimpl<const P: u32> StaticModInt<P> {\n \
    \   #[inline]\n    pub fn new<T: Into<StaticModInt<P>>>(x: T) -> Self {\n    \
    \    x.into()\n    }\n\n    #[inline(always)]\n    pub const fn modulus() -> u32\
    \ {\n        P\n    }\n\n    #[inline]\n    pub const fn raw(val: u32) -> Self\
    \ {\n        Self(val)\n    }\n\n    #[inline]\n    pub const fn val(self) ->\
    \ u32 {\n        self.0\n    }\n\n    #[inline]\n    pub fn inv(self) -> Self\
    \ {\n        assert_ne!(self.0, 0);\n        self.pow(P as usize - 2)\n    }\n\
    \n    pub fn pow(mut self, mut k: usize) -> Self {\n        let mut res = Self::from(1);\n\
    \        while k != 0 {\n            if k & 1 != 0 {\n                res *= self;\n\
    \            }\n            k >>= 1;\n            self *= self;\n        }\n \
    \       res\n    }\n\n    pub fn sqrt(self) -> Option<Self> {\n        let p =\
    \ Self::modulus() as usize;\n        if self.val() < 2 {\n            return Some(self);\n\
    \        } else if self.pow(p - 1 >> 1).val() != 1 {\n            return None;\n\
    \        }\n        let mut b = Self::from(1);\n        while b.pow((p - 1 >>\
    \ 1) as usize).val() == 1 {\n            b += 1;\n        }\n        let mut e\
    \ = (p - 1).trailing_zeros() as usize;\n        let m = (p - 1) >> e;\n      \
    \  let mut x = self.pow(m - 1 >> 1);\n        let mut y = self * x * x;\n    \
    \    x *= self;\n        let mut z = b.pow(m);\n        while y.val() != 1 {\n\
    \            let mut j = 0;\n            let mut t = y;\n            while t.val()\
    \ != 1 {\n                j += 1;\n                t *= t;\n            }\n  \
    \          z = z.pow(1 << e - j - 1);\n            x *= z;\n            z *= z;\n\
    \            y *= z;\n            e = j;\n        }\n        Some(x)\n    }\n\
    }\n\nimpl ModInt for DynamicModInt {\n    #[inline(always)]\n    fn modulus()\
    \ -> u32 {\n        BARRETT.modulus()\n    }\n\n    #[inline]\n    fn raw(val:\
    \ u32) -> Self {\n        Self(val)\n    }\n\n    #[inline]\n    fn val(self)\
    \ -> u32 {\n        self.0\n    }\n\n    #[inline]\n    fn inv(self) -> Self {\n\
    \        self.inv()\n    }\n\n    fn pow(self, k: usize) -> Self {\n        self.pow(k)\n\
    \    }\n\n    fn sqrt(self) -> Option<Self> {\n        self.sqrt()\n    }\n}\n\
    \nimpl DynamicModInt {\n    #[inline]\n    pub fn new<T: Into<DynamicModInt>>(x:\
    \ T) -> Self {\n        x.into()\n    }\n\n    #[inline(always)]\n    pub fn modulus()\
    \ -> u32 {\n        BARRETT.modulus()\n    }\n\n    #[inline]\n    pub fn raw(val:\
    \ u32) -> Self {\n        Self(val)\n    }\n\n    #[inline]\n    pub fn val(self)\
    \ -> u32 {\n        self.0\n    }\n\n    #[inline]\n    pub fn inv(self) -> Self\
    \ {\n        let (g, x) = extgcd(self.0, Self::modulus());\n        assert_eq!(g,\
    \ 1);\n        Self(x)\n    }\n\n    pub fn pow(mut self, mut k: usize) -> Self\
    \ {\n        let mut res = Self::from(1);\n        while k != 0 {\n          \
    \  if k & 1 != 0 {\n                res *= self;\n            }\n            k\
    \ >>= 1;\n            self *= self;\n        }\n        res\n    }\n\n    pub\
    \ fn sqrt(self) -> Option<Self> {\n        let p = Self::modulus() as usize;\n\
    \        if self.val() < 2 {\n            return Some(self);\n        } else if\
    \ self.pow(p - 1 >> 1).val() != 1 {\n            return None;\n        }\n   \
    \     let mut b = Self::from(1);\n        while b.pow((p - 1 >> 1) as usize).val()\
    \ == 1 {\n            b += 1;\n        }\n        let mut e = (p - 1).trailing_zeros()\
    \ as usize;\n        let m = (p - 1) >> e;\n        let mut x = self.pow(m - 1\
    \ >> 1);\n        let mut y = self * x * x;\n        x *= self;\n        let mut\
    \ z = b.pow(m);\n        while y.val() != 1 {\n            let mut j = 0;\n  \
    \          let mut t = y;\n            while t.val() != 1 {\n                j\
    \ += 1;\n                t *= t;\n            }\n            z = z.pow(1 << e\
    \ - j - 1);\n            x *= z;\n            z *= z;\n            y *= z;\n \
    \           e = j;\n        }\n        Some(x)\n    }\n\n    pub fn set_modulus(modulus:\
    \ u32) {\n        BARRETT.set(modulus)\n    }\n}\n\nstruct Barrett {\n    m: AtomicU32,\n\
    \    im: AtomicU64,\n}\n\nimpl Barrett {\n    const fn new(m: u32) -> Self {\n\
    \        Self {\n            m: AtomicU32::new(m),\n            im: AtomicU64::new((!0\
    \ / m as u64).wrapping_add(1)),\n        }\n    }\n\n    #[inline]\n    fn set(&self,\
    \ m: u32) {\n        let im = (!0 / m as u64).wrapping_add(1);\n        self.m.store(m,\
    \ atomic::Ordering::SeqCst);\n        self.im.store(im, atomic::Ordering::SeqCst);\n\
    \    }\n\n    #[inline]\n    fn modulus(&self) -> u32 {\n        self.m.load(atomic::Ordering::SeqCst)\n\
    \    }\n\n    #[inline]\n    fn mul(&self, a: u32, b: u32) -> u32 {\n        let\
    \ m = self.m.load(atomic::Ordering::SeqCst);\n        let im = self.im.load(atomic::Ordering::SeqCst);\n\
    \        let mut z = a as u64;\n        z *= b as u64;\n        let x = (((z as\
    \ u128) * (im as u128)) >> 64) as u64;\n        let mut v = z.wrapping_sub(x.wrapping_mul(m\
    \ as u64)) as u32;\n        if m <= v {\n            v = v.wrapping_add(m);\n\
    \        }\n        v\n    }\n}\n\nstatic BARRETT: Barrett = Barrett::new(998_244_353);\n\
    \nimpl<const P: u32> FromStr for StaticModInt<P> {\n    type Err = ParseIntError;\n\
    \    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        s.parse::<i64>().map(Self::from)\n\
    \    }\n}\n\nimpl FromStr for DynamicModInt {\n    type Err = ParseIntError;\n\
    \    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        s.parse::<i64>().map(Self::from)\n\
    \    }\n}\n\nimpl<const P: u32> fmt::Display for StaticModInt<P> {\n    fn fmt(&self,\
    \ f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n\
    \    }\n}\n\nimpl fmt::Display for DynamicModInt {\n    fn fmt(&self, f: &mut\
    \ fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n  \
    \  }\n}\n\nimpl<const P: u32> fmt::Debug for StaticModInt<P> {\n    fn fmt(&self,\
    \ f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if let Some((num, den))\
    \ = rat_convert(self.0 as u64, P as u64, 1025) {\n            write!(f, \"{}\"\
    , num)?;\n            if den != 1 {\n                write!(f, \"/{}\", den)?;\n\
    \            }\n        } else if let Some((num, den)) = rat_convert((P - self.0)\
    \ as u64, P as u64, 1025) {\n            write!(f, \"-{}\", num)?;\n         \
    \   if den != 1 {\n                write!(f, \"/{}\", den)?;\n            }\n\
    \        } else {\n            write!(f, \"{}\", self.0)?;\n        }\n      \
    \  Ok(())\n    }\n}\n\nimpl fmt::Debug for DynamicModInt {\n    fn fmt(&self,\
    \ f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n\
    \    }\n}\n\nmacro_rules! impl_from_integer {\n    ($(($t1:ty, $t2:ty)),*) =>\
    \ {\n        $(\n            impl<const P: u32> From<$t1> for StaticModInt<P>\
    \ {\n                fn from(x: $t1) -> Self {\n                    Self((x as\
    \ $t2).rem_euclid(P as $t2) as u32)\n                }\n            }\n      \
    \      impl From<$t1> for DynamicModInt {\n                fn from(x: $t1) ->\
    \ Self {\n                    Self((x as $t2).rem_euclid(Self::modulus() as $t2)\
    \ as u32)\n                }\n            }\n        )*\n    };\n}\n\nimpl_from_integer!(\n\
    \    (i8, i32),\n    (i16, i32),\n    (i32, i32),\n    (i64, i64),\n    (isize,\
    \ i64),\n    (i128, i128),\n    (u8, u32),\n    (u16, u32),\n    (u32, u32),\n\
    \    (u64, u64),\n    (usize, u64),\n    (u128, u128)\n);\n\nimpl<const P: u32,\
    \ T: Into<Self>> AddAssign<T> for StaticModInt<P> {\n    fn add_assign(&mut self,\
    \ rhs: T) {\n        self.0 += rhs.into().0;\n        if self.0 >= P {\n     \
    \       self.0 -= P;\n        }\n    }\n}\n\nimpl<T: Into<Self>> AddAssign<T>\
    \ for DynamicModInt {\n    fn add_assign(&mut self, rhs: T) {\n        self.0\
    \ += rhs.into().0;\n        if self.0 >= Self::modulus() {\n            self.0\
    \ -= Self::modulus();\n        }\n    }\n}\n\nimpl<const P: u32, T: Into<Self>>\
    \ SubAssign<T> for StaticModInt<P> {\n    fn sub_assign(&mut self, rhs: T) {\n\
    \        let rhs = rhs.into().0;\n        if self.0 < rhs {\n            self.0\
    \ += P;\n        }\n        self.0 -= rhs;\n    }\n}\n\nimpl<T: Into<Self>> SubAssign<T>\
    \ for DynamicModInt {\n    fn sub_assign(&mut self, rhs: T) {\n        let rhs\
    \ = rhs.into().0;\n        if self.0 < rhs {\n            self.0 += Self::modulus();\n\
    \        }\n        self.0 -= rhs;\n    }\n}\n\nimpl<const P: u32, T: Into<Self>>\
    \ MulAssign<T> for StaticModInt<P> {\n    fn mul_assign(&mut self, rhs: T) {\n\
    \        *self = Self((self.0 as u64 * rhs.into().0 as u64 % P as u64) as u32);\n\
    \    }\n}\n\nimpl<T: Into<Self>> MulAssign<T> for DynamicModInt {\n    fn mul_assign(&mut\
    \ self, rhs: T) {\n        *self = Self(BARRETT.mul(self.0, rhs.into().0));\n\
    \    }\n}\n\nimpl<const P: u32, T: Into<Self>> DivAssign<T> for StaticModInt<P>\
    \ {\n    fn div_assign(&mut self, rhs: T) {\n        *self *= rhs.into().inv()\n\
    \    }\n}\n\nimpl<T: Into<Self>> DivAssign<T> for DynamicModInt {\n    fn div_assign(&mut\
    \ self, rhs: T) {\n        *self = *self * rhs.into().inv()\n    }\n}\n\nimpl<const\
    \ P: u32> Neg for StaticModInt<P> {\n    type Output = Self;\n    fn neg(self)\
    \ -> Self::Output {\n        if self.0 == 0 {\n            Self(0)\n        }\
    \ else {\n            Self(P - self.0)\n        }\n    }\n}\n\nimpl Neg for DynamicModInt\
    \ {\n    type Output = Self;\n    fn neg(self) -> Self::Output {\n        if self.0\
    \ == 0 {\n            Self(0)\n        } else {\n            Self(Self::modulus()\
    \ - self.0)\n        }\n    }\n}\n\nimpl<const P: u32> Neg for &StaticModInt<P>\
    \ {\n    type Output = StaticModInt<P>;\n    fn neg(self) -> Self::Output {\n\
    \        if self.0 == 0 {\n            StaticModInt(0)\n        } else {\n   \
    \         StaticModInt(P - self.0)\n        }\n    }\n}\n\nimpl Neg for &DynamicModInt\
    \ {\n    type Output = DynamicModInt;\n    fn neg(self) -> Self::Output {\n  \
    \      if self.0 == 0 {\n            DynamicModInt(0)\n        } else {\n    \
    \        DynamicModInt(DynamicModInt::modulus() - self.0)\n        }\n    }\n\
    }\n\nmacro_rules! impl_ops {\n    ($(\n        $trait:ident,\n        $trait_assign:ident,\n\
    \        $fn:ident,\n        $fn_assign:ident,\n    )*) => {$(\n        impl<const\
    \ P: u32> $trait_assign<&StaticModInt<P>> for StaticModInt<P> {\n            fn\
    \ $fn_assign(&mut self, rhs: &StaticModInt<P>) {\n                self.$fn_assign(*rhs);\n\
    \            }\n        }\n        impl<const P: u32, T: Into<StaticModInt<P>>>\
    \ $trait<T> for StaticModInt<P> {\n            type Output = StaticModInt<P>;\n\
    \            fn $fn(mut self, rhs: T) -> Self::Output {\n                self.$fn_assign(rhs);\n\
    \                self\n            }\n        }\n        impl<const P: u32> $trait<&StaticModInt<P>>\
    \ for StaticModInt<P> {\n            type Output = StaticModInt<P>;\n        \
    \    fn $fn(self, rhs: &StaticModInt<P>) -> Self::Output {\n                self.$fn(*rhs)\n\
    \            }\n        }\n        impl<const P: u32, T: Into<StaticModInt<P>>>\
    \ $trait<T> for &StaticModInt<P> {\n            type Output = StaticModInt<P>;\n\
    \            fn $fn(self, rhs: T) -> Self::Output {\n                (*self).$fn(rhs)\n\
    \            }\n        }\n        impl<const P: u32> $trait<&StaticModInt<P>>\
    \ for &StaticModInt<P> {\n            type Output = StaticModInt<P>;\n       \
    \     fn $fn(self, rhs: &StaticModInt<P>) -> Self::Output {\n                (*self).$fn(*rhs)\n\
    \            }\n        }\n        impl $trait_assign<&DynamicModInt> for DynamicModInt\
    \ {\n            fn $fn_assign(&mut self, rhs: &DynamicModInt) {\n           \
    \     self.$fn_assign(*rhs);\n            }\n        }\n        impl<T: Into<DynamicModInt>>\
    \ $trait<T> for DynamicModInt {\n            type Output = DynamicModInt;\n  \
    \          fn $fn(mut self, rhs: T) -> Self::Output {\n                self.$fn_assign(rhs);\n\
    \                self\n            }\n        }\n        impl $trait<&DynamicModInt>\
    \ for DynamicModInt {\n            type Output = DynamicModInt;\n            fn\
    \ $fn(self, rhs: &DynamicModInt) -> Self::Output {\n                self.$fn(*rhs)\n\
    \            }\n        }\n        impl<T: Into<DynamicModInt>> $trait<T> for\
    \ &DynamicModInt {\n            type Output = DynamicModInt;\n            fn $fn(self,\
    \ rhs: T) -> Self::Output {\n                (*self).$fn(rhs)\n            }\n\
    \        }\n        impl $trait<&DynamicModInt> for &DynamicModInt {\n       \
    \     type Output = DynamicModInt;\n            fn $fn(self, rhs: &DynamicModInt)\
    \ -> Self::Output {\n                (*self).$fn(*rhs)\n            }\n      \
    \  }\n    )*};\n}\n\nimpl_ops! {\n    Add, AddAssign, add, add_assign,\n    Sub,\
    \ SubAssign, sub, sub_assign,\n    Mul, MulAssign, mul, mul_assign,\n    Div,\
    \ DivAssign, div, div_assign,\n}\n\nimpl<const P: u32> Sum for StaticModInt<P>\
    \ {\n    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.fold(Self::raw(0),\
    \ |b, x| b + x)\n    }\n}\n\nimpl<const P: u32> Product for StaticModInt<P> {\n\
    \    fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.fold(Self::from(1),\
    \ |b, x| b * x)\n    }\n}\n\nimpl<'a, const P: u32> Sum<&'a Self> for StaticModInt<P>\
    \ {\n    fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n        iter.fold(Self::raw(0),\
    \ |b, x| b + x)\n    }\n}\n\nimpl<'a, const P: u32> Product<&'a Self> for StaticModInt<P>\
    \ {\n    fn product<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n       \
    \ iter.fold(Self::from(1), |b, x| b * x)\n    }\n}\n\nimpl<const P: u32> StaticModInt<P>\
    \ {\n    pub const G: u32 = ntt_info(P).0;\n    pub const RANK2: usize = ntt_info(P).1;\n\
    \    pub const ROOT: [u32; 30] = ntt_info(P).2;\n    pub const IROOT: [u32; 30]\
    \ = ntt_info(P).3;\n    pub const RATE2: [u32; 30] = ntt_info(P).4;\n    pub const\
    \ IRATE2: [u32; 30] = ntt_info(P).5;\n    pub const RATE3: [u32; 30] = ntt_info(P).6;\n\
    \    pub const IRATE3: [u32; 30] = ntt_info(P).7;\n    pub const IS_NTT_FRIENDLY:\
    \ bool = is_prime(P) && Self::RANK2 >= 21;\n}\n\nimpl<const P: u32> Zero for StaticModInt<P>\
    \ {\n    fn zero() -> Self {\n        Self(0)\n    }\n\n    fn is_zero(&self)\
    \ -> bool {\n        self.0 == 0\n    }\n}\n\nimpl<const P: u32> One for StaticModInt<P>\
    \ {\n    fn one() -> Self {\n        Self::new(1)\n    }\n\n    fn is_one(&self)\
    \ -> bool {\n        self == &Self::one()\n    }\n}\n\nimpl Zero for DynamicModInt\
    \ {\n    fn zero() -> Self {\n        Self(0)\n    }\n\n    fn is_zero(&self)\
    \ -> bool {\n        self.0 == 0\n    }\n}\n\nimpl One for DynamicModInt {\n \
    \   fn one() -> Self {\n        Self::new(1)\n    }\n\n    fn is_one(&self) ->\
    \ bool {\n        self == &Self::one()\n    }\n}\n"
  dependsOn:
  - crates/algebraic/algebraic/src/lib.rs
  isVerificationFile: false
  path: crates/number-theory/modint/src/lib.rs
  requiredBy:
  - crates/convolution/convolution-naive/src/lib.rs
  - crates/convolution/convolution-arbitrary-mod/src/lib.rs
  - crates/convolution/convolution-ntt-friendly/src/lib.rs
  - crates/convolution/convolution-u64/src/lib.rs
  - crates/string/wildcard-pattern-matching/src/lib.rs
  - crates/polynomial/formal-power-series/src/lib.rs
  - crates/polynomial/composition/src/lib.rs
  - crates/polynomial/shift-of-sampling-points/src/lib.rs
  - crates/polynomial/power-projection/src/lib.rs
  - crates/polynomial/polynomial-interpolation/src/lib.rs
  - crates/polynomial/lagrange-interpolation/src/lib.rs
  - crates/polynomial/berlekamp-massey/src/lib.rs
  - crates/polynomial/bostan-mori/src/lib.rs
  - crates/polynomial/compositional-inverse/src/lib.rs
  - crates/number-theory/stirling-first-fixed-k/src/lib.rs
  - crates/number-theory/stirling-first/src/lib.rs
  - crates/number-theory/stirling-second-fixed-k/src/lib.rs
  - crates/number-theory/stirling-second/src/lib.rs
  - crates/number-theory/q-binomial/src/lib.rs
  - crates/number-theory/combination/src/lib.rs
  - crates/graph/count-spanning-tree-undirected/src/lib.rs
  - crates/graph/count-spanning-tree-directed/src/lib.rs
  timestamp: '2025-01-11 09:03:35+00:00'
  verificationStatus: LIBRARY_ALL_AC
  verifiedWith:
  - verify/log_of_formal_power_series/src/main.rs
  - verify/sum_of_multiplicative_function/src/main.rs
  - verify/polynomial_interpolation/src/main.rs
  - verify/stirling_number_of_the_first_kind/src/main.rs
  - verify/find_linear_recurrence/src/main.rs
  - verify/matrix_det/src/main.rs
  - verify/subset_convolution/src/main.rs
  - verify/inv_of_formal_power_series/src/main.rs
  - verify/count_spanning_tree_undirected/src/main.rs
  - verify/composition_of_formal_power_series_large/src/main.rs
  - verify/vertex_set_path_composite/src/main.rs
  - verify/unionfind_with_potential_non_commutative_group/src/main.rs
  - verify/tree_path_composite_sum/src/main.rs
  - verify/q_binomial_coefficient_prime_mod/src/main.rs
  - verify/multipoint_evaluation/src/main.rs
  - verify/matrix_product/src/main.rs
  - verify/sqrt_mod/src/main.rs
  - verify/exp_of_formal_power_series/src/main.rs
  - verify/range_affine_point_get/src/main.rs
  - verify/trie_yuki1269/src/main.rs
  - verify/kth_term_of_linearly_recurrent_sequence/src/main.rs
  - verify/stirling_number_of_the_first_kind_fixed_k/src/main.rs
  - verify/inverse_matrix/src/main.rs
  - verify/division_of_polynomials/src/main.rs
  - verify/count_spanning_tree_directed/src/main.rs
  - verify/pow_of_formal_power_series/src/main.rs
  - verify/discrete_logarithm_mod/src/main.rs
  - verify/sqrt_of_formal_power_series/src/main.rs
  - verify/point_set_tree_path_composite_sum_fixed_root/src/main.rs
  - verify/compositional_inverse_of_formal_power_series_large/src/main.rs
  - verify/static_rectangle_add_rectangle_sum/src/main.rs
  - verify/convolution_mod/src/main.rs
  - verify/binomial_coefficient_prime_mod/src/main.rs
  - verify/pow_of_matrix/src/main.rs
  - verify/stirling_number_of_the_second_kind_fixed_k/src/main.rs
  - verify/shift_of_sampling_points_of_polynomial/src/main.rs
  - verify/range_parallel_unionfind/src/main.rs
  - verify/bitwise_or_convolution/src/main.rs
  - verify/convolution_mod_1000000007/src/main.rs
  - verify/stirling_number_of_the_second_kind/src/main.rs
  - verify/polynomial_taylor_shift/src/main.rs
documentation_of: crates/number-theory/modint/src/lib.rs
layout: document
redirect_from:
- /library/crates/number-theory/modint/src/lib.rs
- /library/crates/number-theory/modint/src/lib.rs.html
title: crates/number-theory/modint/src/lib.rs
---
