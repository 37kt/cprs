---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: crates/number_theory/modint/static_modint/src/lib.rs
    title: crates/number_theory/modint/static_modint/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/number_theory/modint/static_modint/src/mod_arithmetic.rs
    title: crates/number_theory/modint/static_modint/src/mod_arithmetic.rs
  - icon: ':heavy_check_mark:'
    path: crates/number_theory/modint/static_modint/src/ntt_precalc.rs
    title: crates/number_theory/modint/static_modint/src/ntt_precalc.rs
  - icon: ':heavy_check_mark:'
    path: crates/number_theory/modint/static_modint/src/numeric.rs
    title: crates/number_theory/modint/static_modint/src/numeric.rs
  _extendedRequiredBy:
  - icon: ':heavy_check_mark:'
    path: crates/convolution/convolution/src/lib.rs
    title: crates/convolution/convolution/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/number_theory/modint/static_modint/src/lib.rs
    title: crates/number_theory/modint/static_modint/src/lib.rs
  - icon: ':heavy_check_mark:'
    path: crates/number_theory/modint/static_modint/src/mod_arithmetic.rs
    title: crates/number_theory/modint/static_modint/src/mod_arithmetic.rs
  - icon: ':heavy_check_mark:'
    path: crates/number_theory/modint/static_modint/src/ntt_precalc.rs
    title: crates/number_theory/modint/static_modint/src/ntt_precalc.rs
  - icon: ':heavy_check_mark:'
    path: crates/number_theory/modint/static_modint/src/numeric.rs
    title: crates/number_theory/modint/static_modint/src/numeric.rs
  - icon: ':heavy_check_mark:'
    path: crates/polynomial/formal_power_series/src/lib.rs
    title: crates/polynomial/formal_power_series/src/lib.rs
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/convolution/bitwise_and_convolution/src/main.rs
    title: verify/library_checker/convolution/bitwise_and_convolution/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/convolution/bitwise_or_convolution/src/main.rs
    title: verify/library_checker/convolution/bitwise_or_convolution/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/convolution/bitwise_xor_convolution/src/main.rs
    title: verify/library_checker/convolution/bitwise_xor_convolution/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/convolution/convolution_mod/src/main.rs
    title: verify/library_checker/convolution/convolution_mod/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/convolution/convolution_mod_1000000007/src/main.rs
    title: verify/library_checker/convolution/convolution_mod_1000000007/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/convolution/gcd_convolution/src/main.rs
    title: verify/library_checker/convolution/gcd_convolution/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/convolution/lcm_convolution/src/main.rs
    title: verify/library_checker/convolution/lcm_convolution/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/data_structure/deque_operate_all_composite/src/main.rs
    title: verify/library_checker/data_structure/deque_operate_all_composite/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/data_structure/dynamic_sequence_range_affine_range_sum/src/main.rs
    title: verify/library_checker/data_structure/dynamic_sequence_range_affine_range_sum/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/data_structure/point_set_range_composite/src/main.rs
    title: verify/library_checker/data_structure/point_set_range_composite/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/data_structure/range_affine_point_get/src/main.rs
    title: verify/library_checker/data_structure/range_affine_point_get/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/data_structure/range_affine_range_sum/src/main.rs
    title: verify/library_checker/data_structure/range_affine_range_sum/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/data_structure/unionfind_with_potential/src/main.rs
    title: verify/library_checker/data_structure/unionfind_with_potential/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/data_structure/unionfind_with_potential_non_commutative_group/src/main.rs
    title: verify/library_checker/data_structure/unionfind_with_potential_non_commutative_group/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/linear_algebra/inverse_matrix/src/main.rs
    title: verify/library_checker/linear_algebra/inverse_matrix/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/linear_algebra/matrix_det/src/main.rs
    title: verify/library_checker/linear_algebra/matrix_det/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/linear_algebra/matrix_product/src/main.rs
    title: verify/library_checker/linear_algebra/matrix_product/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/linear_algebra/matrix_rank/src/main.rs
    title: verify/library_checker/linear_algebra/matrix_rank/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/linear_algebra/pow_of_matrix/src/main.rs
    title: verify/library_checker/linear_algebra/pow_of_matrix/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/polynomial/exp_of_formal_power_series/src/main.rs
    title: verify/library_checker/polynomial/exp_of_formal_power_series/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/polynomial/inv_of_formal_power_series/src/main.rs
    title: verify/library_checker/polynomial/inv_of_formal_power_series/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/polynomial/log_of_formal_power_series/src/main.rs
    title: verify/library_checker/polynomial/log_of_formal_power_series/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/polynomial/pow_of_formal_power_series/src/main.rs
    title: verify/library_checker/polynomial/pow_of_formal_power_series/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/polynomial/sqrt_of_formal_power_series/src/main.rs
    title: verify/library_checker/polynomial/sqrt_of_formal_power_series/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/tree/frequency_table_of_tree_distance/src/main.rs
    title: verify/library_checker/tree/frequency_table_of_tree_distance/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/tree/point_set_tree_path_composite_sum/src/main.rs
    title: verify/library_checker/tree/point_set_tree_path_composite_sum/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/tree/point_set_tree_path_composite_sum_fixed_root/src/main.rs
    title: verify/library_checker/tree/point_set_tree_path_composite_sum_fixed_root/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/tree/tree_path_composite_sum/src/main.rs
    title: verify/library_checker/tree/tree_path_composite_sum/src/main.rs
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/tree/vertex_set_path_composite/src/main.rs
    title: verify/library_checker/tree/vertex_set_path_composite/src/main.rs
  _isVerificationFailed: false
  _pathExtension: rs
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    links: []
  bundledCode: "Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/onlinejudge_verify/documentation/build.py\"\
    , line 71, in _render_source_code_stat\n    bundled_code = language.bundle(stat.path,\
    \ basedir=basedir, options={'include_paths': [basedir]}).decode()\n          \
    \         ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  File \"/opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/onlinejudge_verify/languages/rust.py\"\
    , line 288, in bundle\n    raise NotImplementedError\nNotImplementedError\n"
  code: "use std::{\n    iter::{Product, Sum},\n    num::ParseIntError,\n    ops::{Add,\
    \ AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},\n    str::FromStr,\n\
    };\n\nuse crate::{\n    mod_arithmetic::{inv_mod, mul_mod, pow_mod},\n    StaticModInt,\n\
    };\n\nimpl<const MOD: u32> StaticModInt<MOD> {\n    pub fn new<T: Into<StaticModInt<MOD>>>(x:\
    \ T) -> Self {\n        x.into()\n    }\n\n    pub const fn from_raw(x: u32) ->\
    \ Self {\n        Self(x)\n    }\n\n    pub const fn modulus() -> u32 {\n    \
    \    MOD\n    }\n\n    pub const fn val(self) -> u32 {\n        self.0\n    }\n\
    \n    pub const fn pow(self, exp: usize) -> Self {\n        Self::from_raw(pow_mod(self.0,\
    \ exp, MOD))\n    }\n\n    pub const fn recip(self) -> Self {\n        if Self::IS_PRIME\
    \ {\n            self.pow(MOD as usize - 2)\n        } else {\n            Self::from_raw(inv_mod(self.0,\
    \ MOD))\n        }\n    }\n\n    pub fn sqrt(self) -> Option<Self> {\n       \
    \ assert!(Self::IS_PRIME);\n\n        let p = Self::modulus() as usize;\n    \
    \    if self.0 < 2 {\n            return Some(self);\n        } else if self.pow((p\
    \ - 1) >> 1).val() != 1 {\n            return None;\n        }\n\n        let\
    \ mut b = Self::from_raw(1);\n        while b.pow((p - 1) >> 1).val() == 1 {\n\
    \            b += 1;\n        }\n\n        let mut e = (p - 1).trailing_zeros()\
    \ as usize;\n        let m = (p - 1) >> e;\n        let mut x = self.pow((m -\
    \ 1) >> 1);\n        let mut y = self * x * x;\n        x *= self;\n        let\
    \ mut z = b.pow(m);\n        while y.val() != 1 {\n            let mut j = 0;\n\
    \            let mut t = y;\n            while t.val() != 1 {\n              \
    \  j += 1;\n                t *= t;\n            }\n            z = z.pow(1 <<\
    \ (e - j - 1));\n            x *= z;\n            z *= z;\n            y *= z;\n\
    \            e = j;\n        }\n\n        Some(x)\n    }\n}\n\nimpl<const MOD:\
    \ u32> From<&StaticModInt<MOD>> for StaticModInt<MOD> {\n    fn from(x: &StaticModInt<MOD>)\
    \ -> Self {\n        *x\n    }\n}\n\nimpl<const MOD: u32> FromStr for StaticModInt<MOD>\
    \ {\n    type Err = ParseIntError;\n\n    fn from_str(s: &str) -> Result<Self,\
    \ Self::Err> {\n        s.parse::<i64>().map(Self::from)\n    }\n}\n\nimpl<const\
    \ MOD: u32> std::fmt::Display for StaticModInt<MOD> {\n    fn fmt(&self, f: &mut\
    \ std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n\
    \    }\n}\n\nimpl<const MOD: u32> std::fmt::Debug for StaticModInt<MOD> {\n  \
    \  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n    \
    \    write!(f, \"{}\", self.0)\n    }\n}\n\nimpl<const MOD: u32> Neg for StaticModInt<MOD>\
    \ {\n    type Output = Self;\n\n    fn neg(self) -> Self::Output {\n        if\
    \ self.0 == 0 {\n            Self(0)\n        } else {\n            Self(MOD -\
    \ self.0)\n        }\n    }\n}\n\nimpl<const MOD: u32> Neg for &StaticModInt<MOD>\
    \ {\n    type Output = StaticModInt<MOD>;\n\n    fn neg(self) -> Self::Output\
    \ {\n        -*self\n    }\n}\nimpl<const MOD: u32, T: Into<StaticModInt<MOD>>>\
    \ Add<T> for StaticModInt<MOD> {\n    type Output = Self;\n\n    fn add(self,\
    \ rhs: T) -> Self::Output {\n        let rhs = rhs.into();\n        let mut x\
    \ = self.0 + rhs.0;\n        if x >= MOD {\n            x -= MOD;\n        }\n\
    \        Self(x)\n    }\n}\n\nimpl<const MOD: u32, T: Into<StaticModInt<MOD>>>\
    \ Sub<T> for StaticModInt<MOD> {\n    type Output = Self;\n\n    fn sub(self,\
    \ rhs: T) -> Self::Output {\n        let rhs = rhs.into();\n        if self.0\
    \ < rhs.0 {\n            Self(MOD + self.0 - rhs.0)\n        } else {\n      \
    \      Self(self.0 - rhs.0)\n        }\n    }\n}\n\nimpl<const MOD: u32, T: Into<StaticModInt<MOD>>>\
    \ Mul<T> for StaticModInt<MOD> {\n    type Output = Self;\n\n    fn mul(self,\
    \ rhs: T) -> Self::Output {\n        let rhs = rhs.into();\n        Self(mul_mod(self.0,\
    \ rhs.0, MOD))\n    }\n}\n\nimpl<const MOD: u32, T: Into<StaticModInt<MOD>>> Div<T>\
    \ for StaticModInt<MOD> {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n\
    \    fn div(self, rhs: T) -> Self::Output {\n        self * rhs.into().recip()\n\
    \    }\n}\n\nmacro_rules! impl_from_integer {\n    ($(($t1:ty, $t2:ty)),*) =>\
    \ {\n        $(\n            impl<const MOD: u32> From<$t1> for StaticModInt<MOD>\
    \ {\n                fn from(x: $t1) -> Self {\n                    Self((x as\
    \ $t2).rem_euclid(MOD as $t2) as u32)\n                }\n            }\n\n  \
    \          impl<const MOD: u32> From<&$t1> for StaticModInt<MOD> {\n         \
    \       fn from(x: &$t1) -> Self {\n                    Self((*x as $t2).rem_euclid(MOD\
    \ as $t2) as u32)\n                }\n            }\n        )*\n    };\n}\n\n\
    impl_from_integer! {\n    (i8, i32),\n    (i16, i32),\n    (i32, i32),\n    (i64,\
    \ i64),\n    (isize, i64),\n    (i128, i128),\n    (u8, u32),\n    (u16, u32),\n\
    \    (u32, u32),\n    (u64, u64),\n    (usize, u64),\n    (u128, u128)\n}\n\n\
    macro_rules! impl_ops {\n    ($(\n        $tr:ident,\n        $tr_a:ident,\n \
    \       $f:ident,\n        $f_a:ident,\n    )*) => {$(\n        impl<const MOD:\
    \ u32, T: Into<StaticModInt<MOD>>> $tr<T> for &StaticModInt<MOD> {\n         \
    \   type Output = StaticModInt<MOD>;\n\n            fn $f(self, rhs: T) -> Self::Output\
    \ {\n                (*self).$f(rhs)\n            }\n        }\n\n        impl<const\
    \ MOD: u32, T: Into<StaticModInt<MOD>>> $tr_a<T> for StaticModInt<MOD> {\n   \
    \         fn $f_a(&mut self, rhs: T) {\n                *self = (*self).$f(rhs);\n\
    \            }\n        }\n    )*};\n}\n\nimpl_ops! {\n    Add, AddAssign, add,\
    \ add_assign,\n    Sub, SubAssign, sub, sub_assign,\n    Mul, MulAssign, mul,\
    \ mul_assign,\n    Div, DivAssign, div, div_assign,\n}\n\nimpl<T: Into<StaticModInt<MOD>>,\
    \ const MOD: u32> Sum<T> for StaticModInt<MOD> {\n    fn sum<I: Iterator<Item\
    \ = T>>(iter: I) -> Self {\n        iter.fold(Self::from_raw(0), |b, x| b + x.into())\n\
    \    }\n}\n\nimpl<T: Into<StaticModInt<MOD>>, const MOD: u32> Product<T> for StaticModInt<MOD>\
    \ {\n    fn product<I: Iterator<Item = T>>(iter: I) -> Self {\n        iter.fold(Self::new(1),\
    \ |b, x| b * x.into())\n    }\n}\n"
  dependsOn:
  - crates/number_theory/modint/static_modint/src/lib.rs
  - crates/number_theory/modint/static_modint/src/mod_arithmetic.rs
  - crates/number_theory/modint/static_modint/src/ntt_precalc.rs
  - crates/number_theory/modint/static_modint/src/numeric.rs
  isVerificationFile: false
  path: crates/number_theory/modint/static_modint/src/ops.rs
  requiredBy:
  - crates/polynomial/formal_power_series/src/lib.rs
  - crates/convolution/convolution/src/lib.rs
  - crates/number_theory/modint/static_modint/src/lib.rs
  - crates/number_theory/modint/static_modint/src/mod_arithmetic.rs
  - crates/number_theory/modint/static_modint/src/numeric.rs
  - crates/number_theory/modint/static_modint/src/ntt_precalc.rs
  timestamp: '2025-04-06 02:35:23+00:00'
  verificationStatus: LIBRARY_ALL_AC
  verifiedWith:
  - verify/library_checker/polynomial/sqrt_of_formal_power_series/src/main.rs
  - verify/library_checker/polynomial/pow_of_formal_power_series/src/main.rs
  - verify/library_checker/polynomial/log_of_formal_power_series/src/main.rs
  - verify/library_checker/polynomial/exp_of_formal_power_series/src/main.rs
  - verify/library_checker/polynomial/inv_of_formal_power_series/src/main.rs
  - verify/library_checker/tree/point_set_tree_path_composite_sum/src/main.rs
  - verify/library_checker/tree/tree_path_composite_sum/src/main.rs
  - verify/library_checker/tree/vertex_set_path_composite/src/main.rs
  - verify/library_checker/tree/frequency_table_of_tree_distance/src/main.rs
  - verify/library_checker/tree/point_set_tree_path_composite_sum_fixed_root/src/main.rs
  - verify/library_checker/convolution/convolution_mod_1000000007/src/main.rs
  - verify/library_checker/convolution/bitwise_and_convolution/src/main.rs
  - verify/library_checker/convolution/bitwise_or_convolution/src/main.rs
  - verify/library_checker/convolution/lcm_convolution/src/main.rs
  - verify/library_checker/convolution/gcd_convolution/src/main.rs
  - verify/library_checker/convolution/convolution_mod/src/main.rs
  - verify/library_checker/convolution/bitwise_xor_convolution/src/main.rs
  - verify/library_checker/data_structure/point_set_range_composite/src/main.rs
  - verify/library_checker/data_structure/range_affine_range_sum/src/main.rs
  - verify/library_checker/data_structure/dynamic_sequence_range_affine_range_sum/src/main.rs
  - verify/library_checker/data_structure/deque_operate_all_composite/src/main.rs
  - verify/library_checker/data_structure/range_affine_point_get/src/main.rs
  - verify/library_checker/data_structure/unionfind_with_potential_non_commutative_group/src/main.rs
  - verify/library_checker/data_structure/unionfind_with_potential/src/main.rs
  - verify/library_checker/linear_algebra/pow_of_matrix/src/main.rs
  - verify/library_checker/linear_algebra/inverse_matrix/src/main.rs
  - verify/library_checker/linear_algebra/matrix_det/src/main.rs
  - verify/library_checker/linear_algebra/matrix_product/src/main.rs
  - verify/library_checker/linear_algebra/matrix_rank/src/main.rs
documentation_of: crates/number_theory/modint/static_modint/src/ops.rs
layout: document
redirect_from:
- /library/crates/number_theory/modint/static_modint/src/ops.rs
- /library/crates/number_theory/modint/static_modint/src/ops.rs.html
title: crates/number_theory/modint/static_modint/src/ops.rs
---
